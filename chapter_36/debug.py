"Debugging with Outer try Statements"
'''
You can also make use of exception handlers to replace Python’s default top-level exception-
handling behavior. By wrapping an entire program (or a call to it) in an outer
try in your top-level code, you can catch any exception that may occur while your
program runs, thereby subverting the default program termination.
'''


"""
In the following, the empty except clause catches any uncaught exception raised while
the program runs. To get hold of the actual exception that occurred in this mode, fetch
the sys.exc_info function call result from the built-in sys module; it returns a tuple
whose first two items contain the current exception’s class and the instance object
raised (more on sys.exc_info in a moment):
"""
# try:
#     ...run program... 
# except:                                         # All uncaught exceptions come here
#     import sys
#     print('uncaught!', sys.exc_info()[0], sys.exc_info()[1]) 


""" 
This structure is commonly used during development, to keep programs active even
after errors occur—within a loop, it allows you to run additional tests without having
to restart. It’s also used when testing other program code,
""" 


"Running In-Process Tests"
# test-driver application that tests other code within the same process
'''
The testdriver function here cycles through a series of test calls (the module testapi
is left abstract in this example). Because an uncaught exception in a test case would
normally kill this test driver, you need to wrap test case calls in a try if you want to
continue the testing process after a test fails. The empty except catches any uncaught
exception generated by a test case as usual, and it uses sys.exc_info to log the exception
to a file. The else clause is run when no exception occurs—the test success case.
'''
import sys 

log = open('testlog', 'a') 
from testapi import moreTests, runNextTest, testName 

def testdriver():
    while moreTests():
        try:
            runNextTest() 
        except:
            print('FAILED', testName(), sys.exc_info()[:2], file=log) 
        else:
            print('PASSED', testName(), file=log) 

testdriver()


"More on sys.exc_info"
'''
The sys.exc_info result used in the last two sections allows an exception handler to
gain access to the most recently raised exception generically. This is especially useful
when using the empty except clause to catch everything blindly, to determine what was raised:
'''
try:
    ...
except:
    ...
    # sys.exc_info()[0:2] are the exception class and instance

""" 
If no exception is being handled, this call returns a tuple containing three None values.
Otherwise, the values returned are (type, value, traceback), where:
    • type is the exception class of the exception being handled.
    • value is the exception class instance that was raised.
    • traceback is a traceback object that represents the call stack at the point where the
    exception originally occurred, and used by the traceback module to generate error
    messages.
"""


'''
sys.exc_info can also sometimes be useful to determine
the specific exception type when catching exception category superclasses.
because in this case you can also get the exception type by fetching
the __class__ attribute of the instance obtained with the as clause, sys.exc_info is often
redundant apart from the empty except:
'''
try: 
    ... 
except General as instance:
    ...
    # instance.__class__ is the exception class 


"""
using Exception for the General exception name here would catch all
nonexit exceptions, similar to an empty except but less extreme, and still giving access
to the exception instance and its class. Even so, using the instance object’s interfaces
and polymorphism is often a better approach than testing exception types—exception
methods can be defined per class and run generically:

As usual, being too specific in Python can limit your code’s flexibility. A polymorphic
approach like the last example here generally supports future evolution better than
explicitly type-specific tests or actions.
"""
try: 
    ... 
except General as instance:
    ...
    # instance.method() does the right thing for this instance


"Displaying Errors and Tracebacks"
'''
exception traceback object available in the prior section’s sys.exc_info
result is also used by the standard library’s traceback module to generate the standard
error message and stack display manually. This file has a handful of interfaces that
support wide customization #badly.py
'''
# badly.py
import traceback 

def inverse(x):
    return 1 / x 

try:
    inverse(0) 
except Exception:
    traceback.print_exc(file=open('badly.exc', 'w')) 
print('Bye') 
