'''
in Python, inheritance happens when an object is qualified, and it involves
searching an attribute definition tree—one or more namespaces.

Every time you
use an expression of the form object.attr where object is an instance or class object,
Python searches the namespace tree from bottom to top, beginning with object, looking
for the first attr it can find.

This includes references to self attributes in your methods.
Because lower definitions in the tree override higher ones, inheritance forms the basis
of specialization.
'''


"""
Attribute Tree Construction
    • Instance attributes are generated by assignments to self attributes in methods.
    • Class attributes are created by statements (assignments) in class statements.
    • Superclass links are made by listing classes in parentheses in a class statement
      header.

    - Python searches
        upward in this tree, from instances to superclasses, each time you use qualification to
        fetch an attribute name from an instance object

Specializing Inherited Methods
    The tree-searching model of inheritance turns out to be a great way to
    specialize systems. Because inheritance finds names in subclasses before it checks superclasses,
    subclasses can replace default behavior by redefining their superclasses’ attributes.

    - In fact, you can build entire systems as hierarchies of classes, which you
        extend by adding new external subclasses rather than changing existing logic in place.


The idea of redefining inherited names leads to a variety of specialization techniques.
For instance, subclasses may replace inherited attributes completely, provide attributes
that a superclass expects to find, and extend superclass methods by calling back to the
superclass from an overridden method.
"""
class Super:
    def method(self):
        print('in Super.method')


class Sub(Super):
    '''
    The Sub class replaces Super’s method function with its own specialized version, but within the replacement,
    Sub calls back to the version exported by Super to carry out the default behavior. In
    other words, Sub.method just extends Super.method’s behavior, rather than replacing it
    completely:
    '''
    def method(self):                                   # Override method
        print('starting Sub.method')                    # Add actions here
        Super.method(self)                              # Run default action
        print('ending Sub.method')


x = Super()                                             # Make a Super instance
x.method()                                              # Runs Super.method 

x = Sub()                                               # Make a Sub instance
x.method()                                              # Runs Sub.method, calls Super.method 
