"Tracing Object Interfaces"
'''
Another common use case for class decorators augments
the interface of each generated instance. Class decorators can essentially install on in-
stances a wrapper or “proxy” logic layer that manages access to their interfaces in some
way.
'''
class Wrapper:
    def __init__(self, object):
        self.wrapped = object                                       # Save object
    def __getattr__(self, attrname):
        print('Trace:', attrname)                                   # Trace fetch
        return getattr(self.wrapped, attrname)                      # Delegate fetch
    
x = Wrapper([1,2,3])                                                # Wrap a list
x.append(4)                                                         # Delegate to list method
print(x.wrapped)                                                    # Print my member


x = Wrapper({"a": 1, "b": 2})                                       # Wrap a dictionary
print(list(x.keys()))                                               # Delegate to dictionary method


""" 
In this code, the Wrapper class intercepts access to any of the wrapped object’s named
attributes, prints a trace message, and uses the getattr built-in to pass off the request
to the wrapped object. Specifically, it traces attribute accesses made outside the wrapped
object’s class; accesses inside the wrapped object’s methods are not caught and
run normally by design. This whole-interface model differs from the behavior of function
decorators, which wrap up just one specific method.
"""


'Tracing interfaces with class decorators'
""" 
Class decorators provide an alternative and convenient way to code this __getattr__
technique to wrap an entire interface. As of both 2.6 and 3.0, for example, the prior
class example can be coded as a class decorator that triggers wrapped instance creation,
instead of passing a premade instance into the wrapper’s constructor (also augmented
here to support keyword arguments with **kargs and to count the number of accesses
made to illustrate changeable state):
""" 
def Tracer(aClass):                                             # On @ decorator
    class Wrapper:
        def __init__(self, *args, **kargs):                     # On instance creation
            self.fetches = 0
            self.wrapped = aClass(*args, **kargs)               # Use enclosing scope name
        def __getattr__(self, attrname):
            print('Trace: ' + attrname)                         # Catches all but own attr
            self.fetches += 1
            return getattr(self.wrapped, attrname)              # Delegate to wrapped obj
    return Wrapper 


if __name__ == '__main__':
    """ 
    Notice how there is one Wrapper class with state retention per decoration, generated by
    the nested class statement in the Tracer function, and how each instance gets its own
    fetches counter by virtue of generating a new Wrapper instance.
    """
    @Tracer
    class Spam:                                         # Spam = Tracer(Spam)
        def display(self):                              # Spam is rebound to Wrapper
            print('Spam!' * 8)
        
    @Tracer
    class Person:                                       # Person = Tracer(Person)
        def __init__(self, name, hours, rate):
            self.name = name 
            self.hours = hours
            self.rate = rate 
        def pay(self):                                  # Accesses outside class traced
            return self.hours * self.rate               # In-method accesses not traced
        
    
    food = Spam()                                       # Triggers Wrapper()
    food.display()                                      # Triggers __getattr__
    print([food.fetches])
    
    bob = Person('Bob', 40, 50)                         # bob is really a Wrapper
    print(bob.name)                                     # Wrapper embeds a Person
    print(bob.pay())
    
    print('')
    sue = Person('Sue', rate=100, hours=60)             # sue is a different Wrapper
    print(sue.name)                                     # with a different Person
    print(sue.pay())
    
    print(bob.name)                                     # bob has different state
    print(bob.pay())
    print([bob.fetches, sue.fetches])                   # Wrapper attrs not traced


'Applying class decorators to built-in types'
'''
we can also use the decorator to wrap up a built-in type such
as a list, as long as we either subclass to allow decoration syntax or perform the decoration
manually—decorator syntax requires a class statement for the @ line. In the
following, x is really a Wrapper again due to the indirection of decoration:
    >>> from interfacetracer import Tracer
    >>> @Tracer
    ... class MyList(list): pass                        # MyList = Tracer(MyList)
    
    >>> x = MyList([1, 2, 3])                           # Triggers Wrapper()
    >>> x.append(4)                                     # Triggers __getattr__, append
    Trace: append
    >>> x.wrapped
    [1, 2, 3, 4]
    
    >>> WrapList = Tracer(list)                         # Or perform decoration manually
    >>> x = WrapList([4, 5, 6])                         # Else subclass statement required
    >>> x.append(7)
    Trace: append
    >>> x.wrapped
    [4, 5, 6, 7]

The decorator approach allows us to move instance creation into the decorator itself,
instead of requiring a premade object to be passed in. Although this seems like a minor
difference, it lets us retain normal instance creation syntax and realize all the benefits
of decorators in general. Rather than requiring all instance creation calls to route objects
through a wrapper manually, we need only augment class definitions with decorator
syntax:
    @Tracer # Decorator approach
    class Person: ...
    bob = Person('Bob', 40, 50)
    sue = Person('Sue', rate=100, hours=60)
    
    class Person: ... # Nondecorator approach
    bob = Wrapper(Person('Bob', 40, 50))
    sue = Wrapper(Person('Sue', rate=100, hours=60))

Assuming you will make more than one instance of a class, and want to apply the
augmentation to every instance of a class, decorators will generally be a net win in terms
of both code size and code maintenance.
'''
